<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>openQA Log Analyzer</title>
    <style>
        body { font-family: sans-serif; margin: 2em; background-color: #fdfdfd; color: #333; }
        h1, h2 { color: #444; }
        form { margin-bottom: 2em; }
        input[type="url"] { width: 50%; padding: 8px; }
        button { padding: 8px 15px; }
        pre { background-color: #f4f4f4; padding: 1em; border: 1px solid #ddd; white-space: pre-wrap; word-wrap: break-word; border-radius: 4px; }
        #debug-frame { margin-top: 2em; }
        .log-error { color: #D8000C; font-weight: bold; }
        .log-debug { color: #666; }
        .log-info { color: #00529B; }
        .job-entry { margin-bottom: 2em; border: 1px solid #ccc; padding: 1em; border-radius: 4px; }
        table { border-collapse: collapse; width: 100%; margin-top: 0.5em; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; vertical-align: top; word-break: break-word; }
        th { background-color: #f2f2f2; font-weight: bold; }
        .settings-key { font-weight: bold; font-family: sans-serif; width: 25%; }
        .settings-value { font-family: monospace; white-space: pre-wrap; }
        .autoinst-log-table .col-timestamp,
        .autoinst-log-table .col-mutex,
        .autoinst-log-table .col-barrier {
            width: 1%;
            white-space: nowrap;
        }
        .highlighted-row {
            background-color: #fff3cd !important;
            transition: background-color 0.5s ease;
        }
        #timeline-container {
            position: relative;
            font-family: monospace;
            font-size: 12px;
        }
        .timeline-svg {
            width: 100%;
            border: 1px solid #ccc;
            background-color: #fdfdfd;
        }
        .timeline-participant-label { font-weight: bold; }
        .timeline-event-marker { cursor: pointer; }
        .timeline-event-marker:hover { stroke: black; stroke-width: 2px; }
        .timeline-tooltip {
            position: absolute; background-color: #333; color: white;
            padding: 5px 10px; border-radius: 4px; pointer-events: none;
            opacity: 0; transition: opacity 0.2s; white-space: pre-wrap;
            max-width: 500px; z-index: 10;
        }
        details {
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 0.5em;
            margin-top: 1em;
            background-color: #f9f9f9;
        }
        summary {
            font-weight: bold;
            cursor: pointer;
            padding: 0.2em;
        }
    </style>
</head>
<body>
    <h1>openQA Log Analyzer</h1>
    <form id="log-form">
        <label for="log_url">Log URL:</label>
        <input type="url" id="log_url" name="log_url" size="100" value="https://openqa.suse.de/tests/18961558/logfile?filename=autoinst-log.txt#line-1515" required>
        <button type="submit">Analyze</button>
    </form>

    <div id="timeline-frame">
        <h2>Merged Timeline</h2>
        <div id="timeline-container"></div>
    </div>

    <div id="results-frame">
        <h2>Job Details</h2>
        <div id="job-details-container">
            <pre id="job-details-content"></pre>
        </div>
    </div>

    <div id="debug-frame">
        <h2>Debug Log</h2>
        <pre id="debug-log-content"></pre>
    </div>

    <script>
        let highlightedRow = null;
        document.getElementById('log-form').addEventListener('submit', function(event) {
            event.preventDefault();
            const logUrl = document.getElementById('log_url').value;
            const jobDetailsContainer = document.getElementById('job-details-container');
            const timelineContainer = document.getElementById('timeline-container');
            const debugLogContent = document.getElementById('debug-log-content');

            // Clear previous results and show loading message
            jobDetailsContainer.innerHTML = '<pre>Analyzing...</pre>';
            timelineContainer.innerHTML = '';
            debugLogContent.innerHTML = '';

            fetch('/analyze', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ log_url: logUrl })
            })
            .then(response => response.json())
            .then(data => {
                jobDetailsContainer.innerHTML = ''; // Clear 'Analyzing...' message

                // Handle debug log first, as it should be present in both success and error responses
                if (data.debug_log && Array.isArray(data.debug_log)) {
                    data.debug_log.forEach(log => {
                        const logEntry = document.createElement('div');
                        logEntry.textContent = `[${log.level.toUpperCase()}] ${log.message}`;
                        logEntry.className = `log-${log.level}`; // Assign class for styling
                        debugLogContent.appendChild(logEntry);
                    });
                }

                // Handle timeline visualization
                if (data.timeline_events && data.timeline_events.length > 0) {
                    renderTimeline(data.timeline_events, data.jobs, 'timeline-container');
                } else {
                    timelineContainer.innerHTML = '<p>No timeline events to display.</p>';
                }

                // Handle main content (job details or error)
                if (data.error) {
                    const errorPre = document.createElement('pre');
                    errorPre.textContent = `Error: ${data.error}`;
                    jobDetailsContainer.appendChild(errorPre);
                } else if (data.jobs) {
                    for (const jobId in data.jobs) {
                        const jobDetails = data.jobs[jobId];

                        const jobDiv = document.createElement('div');
                        jobDiv.className = 'job-entry';

                        const title = document.createElement('h3');
                        const jobLink = document.createElement('a');
                        jobLink.href = jobDetails.job_url;
                        jobLink.textContent = jobId;
                        jobLink.target = '_blank';
                        jobLink.rel = 'noopener noreferrer';

                        title.appendChild(jobLink);

                        if (jobDetails.error) {
                            title.append(` - Error fetching details`);
                        } else {
                            title.append(` - ${jobDetails.short_name}`);
                        }

                        jobDiv.appendChild(title);

                        // Separate specific fields to be collapsible
                        const autoinstLog = jobDetails['autoinst-log'];
                        const settings = jobDetails['settings'];

                        // Create a copy of jobDetails to show the rest
                        const otherDetails = { ...jobDetails };
                        delete otherDetails['autoinst-log'];
                        delete otherDetails['settings'];

                        if (settings) {
                            jobDiv.appendChild(createCollapsibleSection('Settings', settings));
                        }

                        if (autoinstLog) {
                            const logSection = createCollapsibleSection('autoinst-log', autoinstLog, jobId);
                            logSection.id = `autoinst-log-${jobId}`;
                            jobDiv.appendChild(logSection);
                        }

                        // Display the rest of the details
                        const otherDetailsPre = document.createElement('pre');
                        otherDetailsPre.textContent = JSON.stringify(otherDetails, null, 2);
                        jobDiv.appendChild(otherDetailsPre);

                        jobDetailsContainer.appendChild(jobDiv);
                    }
                } else {
                    // Fallback for unexpected structure from a 2xx response
                    const fallbackPre = document.createElement('pre');
                    fallbackPre.textContent = 'Received an unexpected response structure.\n\n' + JSON.stringify(data, null, 2);
                    jobDetailsContainer.appendChild(fallbackPre);
                }
            })
            .catch(error => {
                console.error('Fetch Error:', error);
                jobDetailsContainer.innerHTML = '<pre>A client-side error occurred. See debug log for details.</pre>';
                const errorEntry = document.createElement('div');
                errorEntry.textContent = `[FATAL] ${error.message}`;
                errorEntry.className = 'log-error';
                debugLogContent.appendChild(errorEntry);
            });
        });

        function renderTimeline(events, jobs, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; // Clear previous timeline

            const getShortName = (jobId) => {
                if (jobs && jobs[jobId] && jobs[jobId].short_name) {
                    return jobs[jobId].short_name;
                }
                return jobId; // Fallback to job id if not found
            };

            const participants = [...new Set(events.map(e => getShortName(e.job_id)))].sort();
            const margin = { top: 20, right: 50, bottom: 40, left: 120 };
            const width = container.clientWidth - margin.left - margin.right;
            const height = participants.length * 40 + margin.top + margin.bottom;

            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute('class', 'timeline-svg');
            svg.setAttribute('width', width + margin.left + margin.right);
            svg.setAttribute('height', height);
            container.appendChild(svg);

            const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
            g.setAttribute('transform', `translate(${margin.left},${margin.top})`);
            svg.appendChild(g);

            // Time scale
            const firstEventTime = new Date(events[0].timestamp).getTime();
            const lastEventTime = new Date(events[events.length - 1].timestamp).getTime();
            const timeDomain = lastEventTime - firstEventTime;

            const xScale = (timestamp) => {
                const eventTime = new Date(timestamp).getTime();
                if (timeDomain === 0) return width / 2;
                return ((eventTime - firstEventTime) / timeDomain) * width;
            };

            // Participant scale (Y-axis)
            const yScale = (participant) => {
                return participants.indexOf(participant) * 40 + 20;
            };

            // Draw participant labels and lifelines
            participants.forEach(p => {
                const y = yScale(p);
                const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                label.setAttribute('x', -10);
                label.setAttribute('y', y);
                label.setAttribute('text-anchor', 'end');
                label.setAttribute('dominant-baseline', 'middle');
                label.setAttribute('class', 'timeline-participant-label');
                label.textContent = p;
                g.appendChild(label);

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute('x1', 0);
                line.setAttribute('x2', width);
                line.setAttribute('y1', y);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#ccc');
                line.setAttribute('stroke-dasharray', '2,2');
                g.appendChild(line);
            });

            // Draw time axis
            const timeAxis = document.createElementNS("http://www.w3.org/2000/svg", "g");
            timeAxis.setAttribute('transform', `translate(0, ${height - margin.top - margin.bottom + 10})`);
            g.appendChild(timeAxis);

            const axisLine = document.createElementNS("http://www.w3.org/2000/svg", "line");
            axisLine.setAttribute('x1', 0);
            axisLine.setAttribute('x2', width);
            axisLine.setAttribute('stroke', 'black');
            timeAxis.appendChild(axisLine);

            const startLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            startLabel.setAttribute('x', 0);
            startLabel.setAttribute('y', 20);
            startLabel.textContent = new Date(firstEventTime).toLocaleTimeString();
            timeAxis.appendChild(startLabel);

            const endLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
            endLabel.setAttribute('x', width);
            endLabel.setAttribute('y', 20);
            endLabel.setAttribute('text-anchor', 'end');
            endLabel.textContent = new Date(lastEventTime).toLocaleTimeString();
            timeAxis.appendChild(endLabel);

            // Tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'timeline-tooltip';
            container.appendChild(tooltip);

            // Draw events
            events.forEach(event => {
                const shortName = getShortName(event.job_id);
                const x = xScale(event.timestamp);
                const y = yScale(shortName);
                let color = '#007bff'; // blue default
                if (event.message.includes('lock')) color = '#28a745'; // green
                if (event.message.includes('unlock')) color = '#17a2b8'; // cyan
                if (event.message.includes('not released')) color = '#dc3545'; // red

                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', 5);
                circle.setAttribute('fill', color);
                circle.setAttribute('class', 'timeline-event-marker');
                g.appendChild(circle);

                circle.addEventListener('mouseover', (e) => {
                    tooltip.style.opacity = '1';
                    tooltip.innerHTML = `<strong>${event.timestamp}</strong><br>${shortName}<br>${cleanLogMessage(event.message)}`;
                });
                circle.addEventListener('mousemove', (e) => {
                    const rect = container.getBoundingClientRect();
                    tooltip.style.left = `${e.clientX - rect.left + 15}px`;
                    tooltip.style.top = `${e.clientY - rect.top + 15}px`;
                });
                circle.addEventListener('mouseout', () => {
                    tooltip.style.opacity = '0';
                });

                circle.addEventListener('click', () => {
                    if (highlightedRow) {
                        highlightedRow.classList.remove('highlighted-row');
                    }

                    const targetElement = document.getElementById(`autoinst-log-${event.job_id}`);
                    const targetRow = document.getElementById(`log-row-${event.job_id}-${event.log_index}`);

                    if (targetElement && targetRow) {
                        targetRow.classList.add('highlighted-row');
                        highlightedRow = targetRow;
                        targetElement.open = true; // Ensure the section is expanded
                        targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                });
            });
        }

        function cleanLogMessage(message) {
            // Remove ANSI escape codes (e.g., \u001b[37m)
            let cleaned = message.replace(/\u001b\[.*?m/g, '');
            // Remove the log prefix (e.g., [debug] [pid:12345])
            cleaned = cleaned.replace(/^\[\w+\]\s\[pid:\d+\]\s*/, '');
            return cleaned;
        }

        function createCollapsibleSection(title, content, jobId) {
            const details = document.createElement('details');
            const summary = document.createElement('summary');
            summary.textContent = title;
            details.appendChild(summary);
 
            // The content might be a string (for errors)
            if (typeof content === 'string') {
                const pre = document.createElement('pre');
                pre.textContent = content;
                details.appendChild(pre);
                return details;
            }
 
            const table = document.createElement('table');
 
            if (title === 'Settings' && typeof content === 'object' && !Array.isArray(content)) {
                const tbody = document.createElement('tbody');
                // Sort keys for consistent order
                for (const [key, value] of Object.entries(content).sort()) {
                    const row = tbody.insertRow();
                    const keyCell = row.insertCell();
                    keyCell.textContent = key;
                    keyCell.className = 'settings-key';
 
                    const valueCell = row.insertCell();
                    valueCell.textContent = value;
                    valueCell.className = 'settings-value';
                }
                table.appendChild(tbody);
                details.appendChild(table);
            } else if (title === 'autoinst-log' && Array.isArray(content)) {
                table.className = 'autoinst-log-table';
                const thead = document.createElement('thead');
                const headerRow = thead.insertRow();
                const columns = [
                    { name: 'Timestamp', key: 'timestamp', class: 'col-timestamp' },
                    { name: 'Mutex', key: 'mutex', class: 'col-mutex' },
                    { name: 'Barrier', key: 'barrier', class: 'col-barrier' },
                    { name: 'Message', key: 'message', class: 'col-message' }
                ];

                columns.forEach(col => {
                    const th = document.createElement('th');
                    th.textContent = col.name;
                    th.className = col.class;
                    headerRow.appendChild(th);
                });
                table.appendChild(thead);
 
                const tbody = document.createElement('tbody');
                content.forEach((logEntry, index) => {
                    const row = tbody.insertRow();
                    row.id = `log-row-${jobId}-${index}`;
                    columns.forEach(col => {
                        const cell = row.insertCell();
                        cell.textContent = logEntry[col.key] || '';
                        cell.className = col.class;
                    });
                });
                table.appendChild(tbody);
                details.appendChild(table);
                details.addEventListener('toggle', () => {
                    if (!details.open && highlightedRow && details.contains(highlightedRow)) {
                        highlightedRow.classList.remove('highlighted-row');
                        highlightedRow = null;
                    }
                });
            } else {
                // Fallback to <pre> for other content
                const pre = document.createElement('pre');
                pre.textContent = JSON.stringify(content, null, 2);
                details.appendChild(pre);
            }
            return details;
        }
    </script>
</body>
</html>
